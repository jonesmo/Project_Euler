# -*- coding: utf-8 -*-
"""Euler 10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QH6R0R6u21y9e79ppPThbtXUeov6KSpm
"""

import numpy as np
import pandas as pd
import string
import math
from itertools import permutations, combinations
import time

"""#10 Summation of Primes
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

Find the sum of all the primes below two million.
"""

def find_primes(number):
  for j in range(2, int(np.rint(number * 0.5)) + 1):
    if number % j == 0:
      return False
  else:
    return True

def find_primes_below(b):
  a = 2
  list_of_primes = []

  for integer in range(a, b):
    is_prime = find_primes(integer)
    if is_prime is True:
      list_of_primes.append(integer)
  
  return list_of_primes

find_primes_below(15)

find_primes_below(2000000)

"""Taking too long. Gotta bring in the Sieve of Eratosthenes."""

def find_primes_below(number):
  list_of_ints = list(range(2, number))
  primes = list_of_ints
  i = 2

  while i <= int(math.sqrt(number)):
    if i == 2:
      continue
    if (i > 2) and (i % 2 == 0):
      primes.remove(i)
    if i in primes:
      for j in range(i*2, number + 1, i):
        if j in primes:
          primes.remove(j)
    i += 1
  
  return primes

list_of_primes = find_primes_below(2000000)

"""Still taking too long"""

#copy-pasted from GeeksforGeeks

# Python Program to find prime numbers in a range
import time
def SieveOfEratosthenes(n):
      
    # Create a boolean array "prime[0..n]" and 
    # initialize all entries it as true. A value 
    # in prime[i] will finally be false if i is
    # Not a prime, else true.
    prime = [True for i in range(n+1)]
     
    p = 2
    while(p * p <= n):
          
        # If prime[p] is not changed, then it is 
       # a prime
        if (prime[p] == True):
              
            # Update all multiples of p
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    c = 0
 
    # Print all prime numbers
    for p in range(2, n):
        if prime[p]:
            c += 1
    return prime
 
# Driver function
t0 = time.time()
c = SieveOfEratosthenes(200000)
#print("Total prime numbers in range:", c)
 
t1 = time.time()
print("Time required:", t1 - t0)
print(c)

#so I'd need to print a list of indices where c is True and that would give me the primes

res = [i for i, val in enumerate(c) if val] 

res[0:20]

print(len(res))
print(res[-10:])

sum(res[2:])

"""Ok, so I'll go back to the previous way and not use remove.  See if I can build a second list that's just primes rather than rebuilding list each time.

#10 Summation of Primes, try 2
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

Find the sum of all the primes below two million.
"""

def find_primes_below(number):
  list_of_ints = list(range(2, number))
  primes = list_of_ints
  i = 2

  while i <= int(math.sqrt(number)):
    if i in primes:
      for j in range(i*2, number + 1, i):
        if j in primes:
          primes.remove(j)
    i += 1
  
  return primes

t0 = time.time()

current_list = find_primes_below(100000)

t1 = time.time()

print(current_list)
print(t1 - t0)

"""Modify this idea so that it positively adds to a list rather than removes from an existing list, though that should be relatively fast... Could also do a version where I mark primes True and then find their indices."""

def primesfrom2to(n):
    """ Input n>=6, Returns a array of primes, 2 <= p < n """
    sieve = np.ones(n//3 + (n%6==2), dtype=np.bool)
    for i in range(1,int(n**0.5)//3+1):
        if sieve[i]:
            k=3*i+1|1
            sieve[       k*k//3     ::2*k] = False
            sieve[k*(k-2*(i&1)+4)//3::2*k] = False
    return np.r_[2,3,((3*np.nonzero(sieve)[0][1:]+1)|1)]

to_add = primesfrom2to(2000000)

sum(to_add)