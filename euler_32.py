# -*- coding: utf-8 -*-
"""Euler 32.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15JFO2Ay9YIeEnURbz8MF-NJnzqe43P6A
"""

import numpy as np
import pandas as pd
import string
import math
from itertools import permutations, combinations

"""#Pandigital Products
We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.

The product 7254 is unusual, as the identity, 39 Ã— 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.

Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.

HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.
"""

#from previous pandigital problem
def pandigital_generator(n):
  these_pandigitals = list(permutations(range(1, n + 1)))
  return these_pandigitals

def digit_combiner(list_of_digits):
  string_version = ''
  for m in list_of_digits:
    current_number = str(m)
    string_version += current_number
  integer_version = int(string_version)
  return integer_version

nine_digit_pandigitals = pandigital_generator(9)

nine_digit_pandigitals[0:10]

nine_digit_pandigitals[0:9]

nine_digit_pandigitals[8:9]

def every_possible_multiplicand(digit_list):
  list_of_multiplicands = []
  num_digits = len(digit_list)
  i = 0
  j = i + 1

  while j <= (num_digits - 2):
    multiplicand_list_form = digit_list[i:j]
    multiplicand = digit_combiner(multiplicand_list_form)
    list_of_multiplicands.append(multiplicand)

    j += 1
  
  return list_of_multiplicands

test = every_possible_multiplicand(nine_digit_pandigitals[0])

print(test)

def every_possible_multiplier(digit_list, multiplicand):
  list_of_multipliers = []
  num_digits = len(digit_list)
  multiplicand_size = len(str(multiplicand))
  end_digit = multiplicand_size + 1

  while end_digit <= (num_digits - 1):
    multiplier_list_form = digit_list[multiplicand_size:end_digit]
    multiplier = digit_combiner(multiplier_list_form)
    list_of_multipliers.append(multiplier)

    end_digit += 1
  
  return list_of_multipliers

test2 = every_possible_multiplier(nine_digit_pandigitals[0], 1234)

print(test2)

def create_multiplicand_multiplier_sets(digit_list):
  multiplicand_multiplier_sets = []
  
  all_multiplicands = every_possible_multiplicand(digit_list)
  
  for each_multiplicand in all_multiplicands:
    all_multipliers = every_possible_multiplier(digit_list, each_multiplicand)
    this_set = [each_multiplicand, all_multipliers]

    multiplicand_multiplier_sets.append(this_set)

  return multiplicand_multiplier_sets

test3 = create_multiplicand_multiplier_sets(nine_digit_pandigitals[0])

print(test3)

def identify_triples(digit_list):
  possible_triples = []
  all_sets = create_multiplicand_multiplier_sets(digit_list)

  for each_set in all_sets:
    num_multipliers = len(each_set[1])
    current_multiplicand = each_set[0]
    j = 0

    while j < num_multipliers:
      current_multiplier = each_set[1][j]
      current_product = current_multiplicand * current_multiplier

      current_triple = [current_multiplicand, current_multiplier, current_product]

      possible_triples.append(current_triple)

      j += 1
  
  return possible_triples

test4 = identify_triples(nine_digit_pandigitals[0])

print(test4)

"""Now it's time to identify which of the triples fit the condition."""

def pandigital_triples(digit_list):
  ding_ding = []
  joined_digit_list = digit_combiner(digit_list)

  possible_triples = identify_triples(digit_list)

  for each_triple in possible_triples:
    joined_triple = digit_combiner(each_triple)

    if joined_triple == joined_digit_list:
      ding_ding.append(each_triple)

  return ding_ding

test5 = pandigital_triples(nine_digit_pandigitals[0])

print(test5)

correct_triples_list = []

for each_pandigital in nine_digit_pandigitals:
  correct_ones = pandigital_triples(each_pandigital)

  if len(correct_ones) == 0:
    continue
  if len(correct_ones) > 0:
    correct_triples_list.append(correct_ones)

print(correct_triples_list)

len(correct_triples_list)

"""So there are 18 of these products, including duplicates.  Got to eliminate duplicates, but not by eliminating those with the same product."""

num_triples = len(correct_triples_list)
duplicates = []

i = 0

while i < num_triples:
  current_triple = correct_triples_list[i]
  current_multiplicand = current_triple[0][0]
  current_multiplier = current_triple[0][1]
  
  j = i + 1
  
  for each_triple in correct_triples_list[j:num_triples]:
    comparison_triple = correct_triples_list[j]
    comparison_multiplicand = comparison_triple[0][0]
    comparison_multiplier = comparison_triple[0][1]

    if current_multiplicand + current_multiplier == comparison_multiplicand + comparison_multiplier:
      print('Look at these two: ', current_triple, comparison_triple)
    
    j += 1
  
  i += 1

finals = correct_triples_list[0:9]

finals

def final_product(triples_list):
  products = []

  for each_triple in triples_list:
    product = each_triple[0][2]
    products.append(product)
  
  return products

list_of_products = final_product(finals)

list_of_products

answer = sum(list_of_products)

answer