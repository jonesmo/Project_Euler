# -*- coding: utf-8 -*-
"""Euler 34 41.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nu-v-aESP__Be-_5ZUl1a72YXtOsz8Ho
"""

import numpy as np
import pandas as pd
import string
import math
from itertools import permutations

"""###34 Digit factorials
145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.

Find the sum of all numbers which are equal to the sum of the factorial of their digits.

Note: As 1! = 1 and 2! = 2 are not sums they are not included.
"""

successful_numbers = []

for i in range(1, 1000000):
  j = 1
  digits = [int(x) for x in str(i)]
  #print(digits)
  factorials = []
  while j <= len(digits):
    current_digit = digits[j - 1]
    current_factorial = math.factorial(current_digit)
    factorials.append(current_factorial)
    j += 1
  sum_of_factorials = sum(factorials)
  if (sum_of_factorials == i):
    successful_numbers.append(i)

successful_numbers

145 + 40585

"""num 34 took 15 minutes

###41 Pandigital prime
We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is also prime.

What is the largest n-digit pandigital prime that exists?
"""

from itertools import permutations

#will start with 9-digit pandigitals

def pandigital_generator(n):
  these_pandigitals = list(permutations(range(0, n + 1)))
  return these_pandigitals

list_nine = pandigital_generator(9)

len(list_nine)

def digit_combiner(list_of_digits):
  string_version = ''
  for m in list_of_digits:
    current_number = str(m)
    string_version += current_number
  integer_version = int(string_version)
  return integer_version

integers_list = []

for z in list_nine:
  current_integer = digit_combiner(z)
  integers_list.append(current_integer)

def primefinder(number):
  for b in range(2, number + 1):
    if (int(number) % int(b)) == 0:
      break
    else:
      return int(number)

primefinder(124763895)

primes = []

for y in integers_list:
  #print(primefinder(y))
  if primefinder(y):
    primes.append(y)

primes

print(len(integers_list))
print(len(primes))

max(primes)

list_eight = pandigital_generator(8)

integers_list = []
primes = []

for z in list_eight:
  current_integer = digit_combiner(z)
  integers_list.append(current_integer)
print(integers_list)

for y in integers_list:
  if primefinder(y) == True:
    primes.append(y)

primes

"""###41 Pandigital prime, try 2

We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is also prime.

What is the largest n-digit pandigital prime that exists?
"""

possible_digits = list(range(1, 10))

possible_digits

def make_an_int(number):
  new_int = ''.join(map(str, number))
  return new_int

pandigitals = []

for i in range(5,10):
  pandigitals_i = list(permutations(range(1, i)))
  for j in pandigitals_i:
    pandigital_int = make_an_int(j)
    pandigitals.append(pandigital_int)

pandigitals[0:10]

pandigitals_ints = [int(c) for c in pandigitals]

pandigitals_ints[0:5]

#figuring out the maximum number of a possible divisor
int(np.rint(np.sqrt(99)))

def find_primes(number):
  for j in range(2, int(np.rint(np.sqrt(number)))):
    if number % j == 0:
      return False
  else:
    return True

pandigital_primes = []

for each in pandigitals_ints:
  test = find_primes(each)
  #print(test)
  if test == True:
    pandigital_primes.append(each)

len(pandigital_primes)

sorted = np.sort(pandigital_primes)

reverse = sorted[::-1]

reverse[0:5]